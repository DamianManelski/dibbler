\section{Features HOWTO}
This recently added section contains information about setting up
various Dibbler features.

\subsection{Stateless vs stateful and IA, TA options}
\label{features-stateless-stateful}
This section explains the difference between stateless and stateful
configurations. IA and TA options usage is also described.

\Note Usually, normal stateful configuration based on non-temporary
addresses should be used. If you don't know, what temporary addresses
are, you don't need them.

There are two kinds of configurations in DHCPv6 (\cite{rfc3315}, \cite{rfc3736}):
\begin{description}
  \item[stateful] -- when addresses (and possibly other parameters)
    are assigned to a client. To perform this kind of configuration,
    four messages are exchanged: \msg{SOLICIT}, \msg{ADVERTISE},
    \msg{REQUEST} and \msg{REPLY}.
  \item[stateless] -- when only parameters are configured (without
    assigning addresses to a client). During execution of this type of
    configuration, only two messages are exchanged: \msg{INF-REQUEST}
    and \msg{REPLY}.
\end{description}

During normal operation, client works in a stateful mode. If not
instructed otherwise, it will request normal (i.e. non-temporary)
addresses. It will use \opt{IA} (Identity Association for
Non-temporary Addresses, see \cite{rfc3315} for details) to request
and retrieve addresses. Since this is a default behavior, it does not
have to be explicitely mentioned in the client configuration
file. Nevertheless, it can be provided:

\begin{Verbatim}
# client.conf
iface eth0 {
  ia
  option dns-server
}
\end{Verbatim}

In a specific circustances, client might be interested in obtaining
only temporary addresses. Although this is still a stateful mode, its
configuration is sligtly different. There is a special option called \opt{TA}
(Identity Association for Temporary Addresses, see \cite{rfc3315} for
details). This option will be used to request and receive temporary
addresses from the client. To force client to request temporary
addresses instead of permanent ones, \verb+ta+ keyword must be used in
client.conf file. If this option is defined, only temporary address
will be requested.

\begin{Verbatim}
# client.conf
iface eth0 {
  ta
  option dns-server
}
\end{Verbatim}

It is also possible to instruct client to work in a stateless mode. It
will not ask for any type of addresses, but will ask for specific
non-adress related configuration parameters, e.g. DNS Servers
information. This can be achieved by using \verb+stateless+
keyword. Since this is a global parameter, it is not defined on an
interface, but as a global option.

\begin{Verbatim}
# client.conf
stateless
iface eth0
{
  option dns-server
}
\end{Verbatim}

Some of the cases mentioned above can be used together. However,
several combinations are illegal. Here is a complete list:
\begin{description}
\item[none] -- Same as \verb+ia+. Client will send \verb+ia+ option
  (stateful autoconfiguration).
\item[ia] -- Client will send \verb+ia+ option (stateful
  autoconfiguration).
\item[ia,ta] -- When both options are specified, client will request
  for both - Non-temporary as well as Temporary addresses (stateful
  autoconfiguration).
\item[stateless] -- Client will request additional configration
  parameters only and will not ask for addresses (stateless
  autoconfiguration).
\item[stateless,ia] -- This combination is not allowed.
\item[stateless,ta] -- This combination is not allowed.
\item[stateless,ia,ta] -- This combination is not allowed.
\end{description}

\subsection{DNS Update}
\label{features-fqdn}
During normal operation, DHCPv6 client receives one or more IPv6 address(es)
from DHCPv6 server. If configured to do so, it can also receive
information about DNS server addresses. As an additional service, DNS
Update can be performed. This feature, sometimes known as Dynamic DNS,
keeps DNS entries up to date. When client boots, it gets its fully
qualified domain name and this name can be used to reach this
particular client.

There are two types of the DNS Updates. First is a so called forward
resolving. It allows to change a node's name into its address,
e.g. malcolm.example.com can be translated into 2000::123. Other kind
of record, which can be updated is a so called reverse resolving. It
allows to obtain full name of a node with know address, e.g. 2000::124
can be translated into zoe.example.com.

To configure this feature, following steps must be executed:

\begin{enumerate}
\item Configure DNS server. DNS server supporting IPv6 and dynamic
  updates must be configured. One example of such server is a BIND
  9.3. It is necessary to allow listening on the IPv6 sockets and
  define that specific domain can be updated. See example below.
\item Configure Dibbler server to provide DNS server informations for
  clients. DNS Updates will be sent to the first DNS server on the
  list of available servers.
\item Configure Dibbler server to work in stateful mode, i.e. that it
  can provide addresses for the clients. This is a default mode, so
  unless configuration was altered, this step is already done. Make
  sure that there is no ,,stateless'' keyword in the
  \verb+server.conf+ file.
\item Define list of the available names in the server configuration
  file. Make sure to use fully qualified domain names
  (e.g. malcolm.example.com), not the hostnames only. 
\item Configure dibbler client to request for DNS Update. Use ,,option
  fqdn'' to achieve this. 
\end{enumerate}
  
\begin{Verbatim}
options {
        listen-on-v6 { any; };
        listen-on { any; };

        // other options here
        // ...
};

zone "example.com" {
          type master;
          file "pri/example.com";
          allow-update { any; };
          allow-transfer { any; };
          allow-query { "any"; };
          notify yes;

      // other options follow
      // ...
};
\end{Verbatim}

\Note Make sure that unix user, which runs BIND, is able to create and
write file pri/example.com.jnl. 

After configuration, client should log following line, which informs
that Dynamic DNS Update was completed successfully.

\begin{verbatim}
2006.07.24 01:52:51 Client Notice    FQDN Configured successfully !
\end{verbatim}

DNS Update can now be verified using dig command line tool (a part of
the dnsutils package). Command syntex is as follows: \verb+dig @(dns-server-address) name record-type+. In the following example,
this query checks for name jayne.example.com at a server located at
2000::1 address. Record type AAAA (standard record for resolving name
into IPv6 address) is requested. dig tool provides server's response
in the \verb+ANSWER SECTION:+ below:

\begin{Verbatim}
v13:/var# dig @2000::1 jayne.example.com AAAA
; <<>> DiG 9.3.2 <<>> @2000::1 jayne.example.com AAAA
; (1 server found)
;; global options:  printcmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 33416
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 2

;; QUESTION SECTION:
;jayne.example.com.             IN      AAAA

;; ANSWER SECTION:
jayne.example.com.      7200    IN      AAAA    2001::e4

;; AUTHORITY SECTION:
example.com.            86400   IN      NS      v13.klub.com.pl.

;; Query time: 6 msec
;; SERVER: 2000::1#53(2000::1)
;; WHEN: Mon Jul 24 01:38:13 2006
;; MSG SIZE  rcvd: 136
\end{Verbatim}

See example server and client configuration files described in a
sections \ref{example-client-fqdn} and \ref{example-server-fqdn}. Also
note that Dibbler distribution should be accompanied with several
example configuration files. Some of them include FQDN usage examples.

\subsection{Address caching}
Previous Dibbler versions assigned a random address from a available
address pool, so the same client received different address each time it
asked for one. In the 0.5.0 release, two new mechanisms were introduced
to make sure that the same client gets the same address each time.

FIXME:

Below is the algorithm used by the server to assign an address to the client.

\begin{itemize}
 \item if the client provided hint, it is valid (i.e. is part of the
       supported address pool) and not used, then assign requested address.
 \item if the client provided hint, it is valid (i.e. is part of the 
       supported address pool) but used, then assign free address from
       the same pool.
 \item if the client provided hint, but it is not valid (i.e. is not
       part of the supported address pool, is link-local or a multicast
       address), then ignore the hint completety.
 \item if the did not provide valid hint, try to assign address
       previously assigned to this client (address caching)
 \item if this is the first time the client is seen, assign any address
       available.
\begin{itemize}
%% see SrvOptions/SrvOptIA_NA.cpp, TSrvOptIA_NA::getFreeAddr() method

\subsection{Relays}
\label{features-relays}
FIXME: Provide description and maybe a figure.

\subsection{XML files}
During its execution, all dibbler components (client, server and
relay) store its internal information in the XML files. In Linux
systems, they are stored in the \verb+/var/lib/dibbler+ directory. In
Windows, current directory (i.e. directory where exe files are
located) is used instead. There are several xml files generated. Since
they are similar for each component, following list provides
description for client only:

\begin{itemize}
\item client-CfgMgr.xml - Represents information read from a
  configuration file as its associated status (e.g. CONFIGURED or
  FAILED).
\item client-IfaceMgr.xml - Represens detected interfaces in the
  operating system, as well as bound sockets and similar information.
\item client-AddrMgr.xml - This is database, which contains identity
  associations with associated addresses.
\end{itemize}
