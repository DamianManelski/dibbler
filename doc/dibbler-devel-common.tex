%%
%% Dibbler - a portable DHCPv6
%%
%% authors: Tomasz Mrugalski <thomson@klub.com.pl>
%%          Marek Senderski <msend@o2.pl>
%%
%% released under GNU GPL v2 or later licence
%%
%%
%% $Id: dibbler-devel-common.tex,v 1.7 2006-07-16 11:24:51 thomson Exp $
%%

\section{Documentation}
There are three parts of the documentation: User's Guide, Developer's
Guide and a Code documentation. Both guides are written in \LaTeX
(*.tex files). To generate PDF files, you need to have \LaTeX
installed. To generate Code documentation, 
a tool called \href{http://www.doxygen.org}{Doxygen} is required. All
documentation is of course available at
\href{http://klub.com.pl/dhcpv6}{Dibbler's homepage}.

To generate all documentation type (in Dibbler source directory):
\begin{verbatim}
make doc oxygen
\end{verbatim}

In this section various common aspects of the Dibbler internal
workings are decribed.

\section{Basic source code informations}
This section describes various aspects of Dibbler compilation, usage
and internal design.

\subsection{Option values and filenames}

DHCPv6 is a relatively new protocol and additional options are in a
specification phase. It means that until standarisation process is
over, they do not have any officially assigned numbers. Once
standarization process is over (and RFC document is released), this
option gets an official number. 

There's pretty good chance that different implementors may choose
diffrent values for those not-yet officialy accepted options. To
change those values in Dibbler, you have to modify file
misc/DHCPConst.h and recompile server or client. Make sure that you
build everything for scratch. Use \verb+make clean+ in Linux and
\verb+Clean up solution+ in Windows before you start building a new
version.

In default build, Dibbler stores all information in the
\verb+/var/lib/dibbler+ directory (Linux) or in the working directory
(Windows). There are multiple files stored in those
directories. However, sometimes there is a need to build Dibbler which uses
different directory or filename. To do so, simply edit
\verb+misc/Portable.h+ file and rebuild everything.

\subsection{Memory Manegement using SmartPtr}
To effectively fight memory leaks, clever mechanism was
introduced. Smart pointers are used to point to all dynamic
structures, e.g. messages, options or client informations in server
database. Smart pointer will free object by itself, when object is no
longer needed. When this is happening? When last smart pointer stops
pointing at the object. There is a tradeoff: normal pointers (*)
should not be mixed with smart pointers. 

Smart pointers are implemented as C++ class templates. Template is
called \verb+SmartPtr<TYPE>+.

To quickly explain smart pointers usage, here's short code example:
\begin{verbatim}
 1 void foo()  {
 2   SmartPtr<TIPv6Addr> addr = new TIPv6Addr("ff02::1:2");
 3   SmartPtr<TIPv6Addr> tmp;
 4   if (!tmp) cout << "Null pointer" << endl;
 5   tmp = addr;
 6   std::cout << addr->getPlain();
 7 }
\end{verbatim}
What's happened in those lines?
\begin{description}
\item[1] -- Function starts.
\item[2] -- New TIPv6Addr object is created. Smart Pointer
  (SmartPtr$<$TIPv6Addr$>$) is also created to point at this object. Using
  normal pointer to achive the same goal would look like this: \\
  \verb+TIPv6Addr * addr = new TIPv6Addr("ff02::1:2");+
\item[3] -- Another pointer is created. It is equivalent of the
  classical pointer (TIPv6Addr * tmp).
\item[4] -- Simple check if pointer does not point to anything.
\item[5] -- Smart pointers can be coppied in a easy way.
\item[6] -- Using object pointed by smart pointer is simple
\item[7] -- Here magic begins. addr and tmp are local variables, so
  they are destroyed here. But they are the only smart pointers which
  access TIPv6Addr object. So they are destroy that object. 
\end{description}

In conclusion, object remain in memory as long as there is at least
one smart pointer which points to this object. SmartPointers can be
easily derefernced. Just add * before them:
\begin{verbatim}
cout << *addr << endl;
\end{verbatim}

SmartPtrs are often used to store various objects in a list. Cool part
of this solution is that you can hold objects of various derived
classes on one list in a very comfortable manner. There is an
additional template defined to create and manipulate such lists. It is
called TContainer. There's also useful macro defined to use this
without typing too much. Here are two examples how to define list of
addresses (both mean exactly the same):
\begin{verbatim}
TContainer< SmartPtr<TIPvAddr> > addrLst;
List(TIPv6Addr) addrLst;
\end{verbatim}

How to use this list? Oh well, another example:
\begin{verbatim}
1  List(TIPv6Addr) addrLst;
2  SmartPtr<TIPv6Addr> ptr = ...;
3  SmartPtr<TIPv6Addr> tmp;
4  addrLst.clear();
5  addrLst.append(ptr);
6  addrLst.first();
7  tmp = addrLst.get();
8  cout << "List contains " << addrLst.count() << " elements" << endl;
9  addrLst.first();
10 while (tmp = addrLst.get()) 
11   cout << *tmp << endl;
\end{verbatim}

And here is description what that code does:

\begin{description}
\item[1] -- Address list declaration.
\item[2,3] -- SmartPtrs declarations. Just to show variable types.
\item[4] -- List can be cleared. All pointers will be destroyed. If
  they were only pointers to point to some objects, those objects will
  be destroyed, too.
\item[5] -- Append object pointed by ptr to the list.
\item[6] -- Rewind list to the beginning.
\item[7] -- Get next object from the list. If list is empty or last
  element was already got, NULL is returned.
\item[8] -- An easy way to count elements on the list.
\item[9] -- Rewind list to the beginning.
\item[10,11] -- A cute example how to print all addresses on the list.
\end{description}

\subsection{Logging}
To log various informations, Log(LOGLEVEL) macros are defined. There
are eight levels of logging:
\begin{description}
\item[Emergency] -- Used to report system wide emergency. Such
  conditions could not occur in the DHCPv6 client o server, so this
  logging level should not be used. Called with
  \verb+Log(Emerg) << "..." << LogEnd+.

\item[Alert] -- Used to alert an administrator about system wide
  alerts. This logging level should not be used in DHCPv6. 
  Called with \verb+Log(Alert) << "..." << LogEnd+.

\item[Critical] -- Used in situations critical to the application,
  e.g. application shutdown. Fatal errors should be logged on this
  level. Called with \verb+Log(Crit) << "..." << LogEnd+.

\item[Error] -- Used to report error situations. For example, problems
  with binding sockets. Called with \verb+Log(Error) << "..." << LogEnd+.

\item[Warning] -- Used to report RFC violations, e.g. missing required
  options, invalid parameters and so on. Called with \verb+Log(Warning) << "..." << LogEnd+.

\item[Notice] -- Used to report normal operations, e.g. address
 assignement or informations about received options. Called with
 \verb+Log(Notice) << "..." << LogEnd+.

\item[Info] -- Used to report detailed information. DHCPv6 protocol
  knowledge might be needed to understand those messages.
  Called with \verb+Log(Info) << "..." << LogEnd+.

\item[Debug] -- Used to report internal informations. Knowledge about
  Dibbler source code might be needed to understand those messages.
  Called with \verb+Log(Debug) << "..." << LogEnd+.
\end{description}

\subsection{Names and prefixes}
To avoid confussion, various prefixes are used in class and variable
names. Class types begin with T (e.g. address class would be named
TAddr), enumeration types begin with E (e.g. state enumaterion would
be names EState). Dibbler is divided into 4 large functional blocks
called managers\footnote{They are described in the following sections
  of this document}: address maganger, interface manager, Configuration
manager, and transmsission manager. Each of them uses different
prefix: Addr, Iface, Cfg or Trans. There are also objects shared among
them: messages (Msg prefix) and options (Opt prefix). Often there are
two derived versions: related to client (Clnt prefix) or related to
server (Clnt). Rel prefix is used to denote Relay related classes. 
Here are examples of some class names:
\begin{description}
\item[TAddrMgr] -- Address manager, common version.
\item[TClntAddrMgr] -- Address manager, client version.
\item[TAddrIface] -- Interface representation, used in address manager.
\item[TAddrAddr] -- Address representation used in address manager.
\item[TSrvIfaceMgr] -- Interface manager, server version.
\item[TClntIfaceIface] -- Interface representation used in client
  interface manager.
\item[TClntMsg] -- Message represented on the client side.
\item[TClntOptPreference] -- Prefernce option used on the client side.
\item[TIfaceSocket] -- Socket used in the interface manager.
\item[TClntCfgAddr] -- Address used in the client config manager.
\end{description}

Also note that class function names start with small letters
(e.g. \verb+bool TOpt::isValid();+) and class variables start with capital
letters (e.g. \verb+bool TOpt::IsValid;+).

\section{Configuration file parsers}
\textbf{Note:} Similar approach is used in server, client and
relay. In following section when reference to a specific file is needed,
client files are used. To find corresponding files related to server and
relay, substitute \verb+Clnt+ with \verb+Srv+ or \verb+Rel+.

Dibbler uses standard lexer/parser. Lexer is generated using flex. Parser is
generated with bison++ (full source code for bison++ is provided with
Dibbler sources). See \verb+ClntCfgMgr/ClntParser.y+ and
ClntCfgMgr/ClntLexer.l for details. Make sure that you have flex installed
(bison++ is provided with the dibbler source code). To generate parser
and lexer code, type:

\begin{verbatim}
make bison (just once, to compile bison++)
make parser (each time you modify *.l or *.y files)
\end{verbatim}

\subsection{Parsing}
Configuration file reading is done using Flex and bison++ tools. Flex
is so called lexer. Its responsibility is to read config file and
translate it into stream of tokens. \footnote{To be precise, Flex
  generates lexers, so it should be called lexer generator.} For
example, this config file:
\begin{verbatim}
iface eth0 {
  class { pool 2000::1-2000::9 }
}
\end{verbatim}

would be translated to following stream of tokens: [IFACE]
[STRING:eth0] [{] [CLASS] [{] [POOL] [ADDR:2000::1] [-] [ADDR:2000::9]
[}] [}]. This stream of token is then passed to parser. This parser is
generated by bison++. Parser checks if that particular sequence of
tokens makes sense. In this example, interface object will be created,
which contains one class object, which contains one pool.

Is is sometimes very useful to define some parameter, usually
associated with some level, on higher scope level. For example, if
there are 3 classes, instead of defining the same valid-lifetime value
on each of them, that parameter may be defined on the interface
level or even at the top level. This is important to remember during
parsing. Each subsequent element must inherit its parent properties
(class object must inherit parameter values defined on the interface
level).

To accomplish this feat, simple stack was implemented. For example, in
server parser, following methods are called before and after interface
definitions.

\begin{verbatim}
void SrvParser::StartIfaceDeclaration()
{
    // create new option (representing this interface) on the parser stack
    ParserOptStack.append(new TSrvParsGlobalOpt(*ParserOptStack.getLast()));
    SrvCfgAddrClassLst.clear();
}

bool SrvParser::EndIfaceDeclaration()
{
    // create and add new interface to SrvCfgMgr
    ...
    // remove last option (representing this interface) from the parser stack
    ParserOptStack.delLast();
    return true;
}   
\end{verbatim}


\subsection{Using parsed values}

Lexer and parser are created in the Client Configuration Manager. See
ClntCfgMgr/ClntCfgMgr.cpp. Following code is executed in the ClntCfgMgr
constructor\footnote{Actual code is much more complicated, but
unnecessary lines were removed for a clarification reasons.}

\begin{verbatim}
yyFlexLexer lexer(\&f,\&clog);
ClntParser parser(\&lexer);
result = parser.yyparse();
matchParsedSystemInterfaces(\&parser);
validateConfig();
\end{verbatim}

f and clog are normal C++ ifstream and ofstrem objects, associated with
configuration file or a standard output. Configuration file is passed to
the constructor of the entire TDHCPClient object, which is usually
located in the main() function.

Example mentioned above works as follows:

\begin{itemize}
 \item Read all interfaces from the system (using System API). This is done in
       Interface Manager and is not important right now.
 \item Create lexer object (it will read configuration file and convert it into stream
       of tokens)
 \item create parser, which will interpret stream of tokens.
 \item Match interfaces present in system with those specified in the configuration
       file.
 \item Validate configuration file to check if there are no logical errors, like T1>T2,
       specified both stateless and request for ia, etc.
\end{itemize}

\subsection{Embedded configuration}

\textbf{Note:} This feature applies to the client only.

Another way of defining client configuration was introduced in 0.5.0
release. Instead of reading configuration file, configuration can be
hardcoded in the binary file itself. See MOD\_CLNT\_EMBEDDED\_CFG flag
description in section \ref{modular-features}.
