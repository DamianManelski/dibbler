%%
%% Dibbler - a portable DHCPv6
%%
%% authors: Tomasz Mrugalski <thomson@klub.com.pl>
%%          Marek Senderski <msend@o2.pl>
%%
%% released under GNU GPL v2 or later licence
%%
%% $Id: dibbler-devel-compile.tex,v 1.5 2004-11-30 00:52:05 thomson Exp $
%%
%% $Log: not supported by cvs2svn $
%% Revision 1.4  2004/11/25 01:16:36  thomson
%% *** empty log message ***
%%
%% Revision 1.3  2004/10/25 20:45:54  thomson
%% Option support, parsers rewritten. ClntIfaceMgr now handles options.
%%
%% Revision 1.2  2004/09/28 16:02:09  thomson
%% no message
%%
%% Revision 1.1  2004/07/05 01:04:40  thomson
%% Initial version.
%%
%%

\section{Compilation}
Currently Dibbler supports two platforms: Linux with kernels 2.4 and
2.6 series and Windows (XP and 2003). Compilation process is system
dependent, so it is described for Linux and Windows separately.

\subsection{Linux}
To compile Dibbler, extract sources, and type:
\begin{verbatim}
make client
make server
\end{verbatim}
to build client and server. Although parser files are generated using
flex and bison++, those generated sources are included and there is
no need to generate them. To generate If someone wants to generate it by hand
instead of using those supplied versions, here are appropriate commands:
\begin{verbatim}
cd ClntCfgMgr
make parser
\end{verbatim}
to generate client parser, and:
\begin{verbatim}
cd SrvCfgMgr
make parser
\end{verbatim}
to generate server parser.

There occassionaly might be problem with compilation, when different
flex version is installed in the system. Proper FlexLexer.h is
provided in the SrvCfgMgr and ClntCfgMgr directories.

\subsection{Windows}
To compile Dibbler under Windows, MS Visual Studio 2003 was
used. Project files are provided in the CVS and source archives.

Select project name (server-winxp or client-winxp), click properties,
choose ,,Debugging'' from ,,Configuration Properties''. Adjust ,,Command
arguments'' to meet your directory.

If you are using MS Visual Studio 2003, there might be a problem with
lowlevel-win32.c file compilation. Compiler might complain about
missing Ipv6IfIndex in \_IP\_ADDAPTER\_ADDRESSES. There is a simple way
to bypass this.  In \verb+Program Files/Microsoft Visual Studio .NET/Vc7/PlatformSDK/Include/+ directory, there is \verb+IPTypes.h+
file. It contains structure:

\begin{verbatim}
typedef struct _IP_ADAPTER_ADDRESSES {
    union {
        ULONGLONG Alignment;
        struct {
            ULONG Length;
            DWORD IfIndex;
        };
    };
    struct _IP_ADAPTER_ADDRESSES *Next;
    PCHAR AdapterName;
    PIP_ADAPTER_UNICAST_ADDRESS FirstUnicastAddress;
    PIP_ADAPTER_ANYCAST_ADDRESS FirstAnycastAddress;
    PIP_ADAPTER_MULTICAST_ADDRESS FirstMulticastAddress;
    PIP_ADAPTER_DNS_SERVER_ADDRESS FirstDnsServerAddress;
    PWCHAR DnsSuffix;
    PWCHAR Description;
    PWCHAR FriendlyName;
    BYTE PhysicalAddress[MAX_ADAPTER_ADDRESS_LENGTH];
    DWORD PhysicalAddressLength;
    DWORD Flags;
    DWORD Mtu;
    DWORD IfType;
    IF_OPER_STATUS OperStatus;
} IP_ADAPTER_ADDRESSES, *PIP_ADAPTER_ADDRESSES;
\end{verbatim}

You should slightly modify it. Just add on additional field:
\verb+DWORD Ipv6IfIndex;+. Now it should look like this:

\begin{verbatim}
typedef struct _IP_ADAPTER_ADDRESSES {
    union {
        ULONGLONG Alignment;
        struct {
            ULONG Length;
            DWORD IfIndex;
        };
    };
    struct _IP_ADAPTER_ADDRESSES *Next;
    PCHAR AdapterName;
    PIP_ADAPTER_UNICAST_ADDRESS FirstUnicastAddress;
    PIP_ADAPTER_ANYCAST_ADDRESS FirstAnycastAddress;
    PIP_ADAPTER_MULTICAST_ADDRESS FirstMulticastAddress;
    PIP_ADAPTER_DNS_SERVER_ADDRESS FirstDnsServerAddress;
    PWCHAR DnsSuffix;
    PWCHAR Description;
    PWCHAR FriendlyName;
    BYTE PhysicalAddress[MAX_ADAPTER_ADDRESS_LENGTH];
    DWORD PhysicalAddressLength;
    DWORD Flags;
    DWORD Mtu;
    DWORD IfType;
    IF_OPER_STATUS OperStatus;
    DWORD Ipv6IfIndex;
} IP_ADAPTER_ADDRESSES, *PIP_ADAPTER_ADDRESSES;
\end{verbatim}

\subsubsection{Flex/bison under Windows}
As was pointed out before, flex and bison++ tools are not required to
successfully build Dibbler. They are only required, if changes are
made to the parsers. Lexer and Parser files (\verb+ClntLexer.*+, \verb+ClntParser.*+, \verb+SrvLexer.*+ and
\verb+SrvParser.*+) are generated by author and placed in CVS and
archives. There is no need to generate them. However, if you insist on
doing so, there is an flex and bison binary included in port-winxp. Take note that
several modifications are required:

\begin{itemize}
\item To generate \verb+ClntParser.cpp+ and \verb+ClntLexer.cpp+ files, you can use
\verb+parser.bat+. After generation, in file \verb+ClntLexer.cpp+ replace: \verb+class istream;+
with: \verb+#include <iostream>+ and \verb+using namespace std;+ lines.
\item flex binary included is slightly modified. It generates

\begin{verbatim}
#include "FlexLexer.h"
\end{verbatim} 
instead of 
\begin{verbatim}
#include <FlexLexer.h>
\end{verbatim} 

You should
add .\ to include path if you have problem with missing \verb+FlexLexer.h+.
Also note that \verb+FlexLexer.h+ is modified (std:: added in several places,
\verb+<fstream.h>+ is replaced with \verb+<fstream>+ etc.)
%%\item In file ClntParser.cpp, substitute line (around 1860): ,,	*++yyvsp = yylval;''
%%with: ,,*++yyvsp = ::yylval;''. This trick is supposed to fix numerous
%%parser problems.
\end{itemize}

Keep in mind that author is in no way a flex/bison guru and found this method
in a painful trial-and-error way. 
